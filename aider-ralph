#!/usr/bin/env bash
#
# aider-ralph - Ralph Wiggum AI Loop Technique for Aider
#
# An iterative AI development methodology that repeatedly feeds aider
# a prompt until completion. Named after The Simpsons character, it
# embodies the philosophy of persistent iteration despite setbacks.
#
# Philosophy:
#   - Iteration > Perfection: Don't aim for perfect on first try
#   - Failures Are Data: Deterministically bad = predictable & informative
#   - Operator Skill Matters: Success depends on writing good prompts
#   - Persistence Wins: Keep trying until success
#
# Usage:
#   aider-ralph --init [PROJECT_NAME]     Initialize a new project
#   aider-ralph [OPTIONS] "<prompt>" [-- AIDER_OPTIONS]
#   aider-ralph [OPTIONS] -f PROMPT_FILE [-- AIDER_OPTIONS]
#
# Examples:
#   aider-ralph --init "My Todo App"
#   aider-ralph "Build a hello world API" --max-iterations 10
#   aider-ralph -f PROMPT.md --completion-promise "DONE" --max-iterations 30
#   aider-ralph "Fix the tests" -- --model sonnet --api-key anthropic=sk-xxx
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Default values
MAX_ITERATIONS=0  # 0 means unlimited
COMPLETION_PROMISE=""
PROMPT=""
PROMPT_FILE=""
VERBOSE=false
DRY_RUN=false
AIDER_OPTS=()
LOG_FILE=""
ITERATION_DELAY=2  # seconds between iterations
DO_INIT=false
PROJECT_NAME=""

# State
CURRENT_ITERATION=0
LOOP_ACTIVE=false

# Cleanup on exit
cleanup() {
    LOOP_ACTIVE=false
    if [[ -n "$LOG_FILE" && -f "$LOG_FILE" ]]; then
        echo -e "\n${CYAN}ğŸ“‹ Log saved to: ${LOG_FILE}${NC}"
    fi
}
trap cleanup EXIT

# Print usage
usage() {
    cat << 'EOF'
aider-ralph - Ralph Wiggum AI Loop Technique for Aider

USAGE:
    aider-ralph --init [PROJECT_NAME]
    aider-ralph [OPTIONS] "<prompt>" [-- AIDER_OPTIONS]
    aider-ralph [OPTIONS] -f PROMPT_FILE [-- AIDER_OPTIONS]

COMMANDS:
    --init [NAME]                Initialize project for aider-ralph
                                 Creates SPECS.md and .ralph/ directory
                                 Optionally provide a project name

OPTIONS:
    -m, --max-iterations <N>     Stop after N iterations (default: unlimited)
                                 STRONGLY RECOMMENDED as a safety net

    -c, --completion-promise <TEXT>
                                 Phrase that signals completion (checked in output)
                                 e.g., "COMPLETE", "DONE", "FINISHED"

    -f, --file <PATH>            Read prompt from file instead of argument
                                 File is re-read each iteration (live updates)

    -d, --delay <SECONDS>        Delay between iterations (default: 2)

    -l, --log <PATH>             Log all output to file

    -v, --verbose                Show detailed progress information

    --dry-run                    Show what would be executed without running

    -h, --help                   Show this help message

AIDER OPTIONS:
    Any options after -- are passed directly to aider.
    Common aider options:
        --model <MODEL>          LLM model to use (sonnet, gpt-4o, etc.)
        --api-key <PROVIDER>=<KEY>  API key for the provider
        --yes                    Auto-confirm all prompts
        --no-git                 Disable git integration
        --watch-files            Watch for file changes

EXAMPLES:
    # Initialize a new project
    aider-ralph --init "My Todo App"

    # Simple loop with iteration limit
    aider-ralph "Build a REST API for todos" --max-iterations 10

    # With completion promise detection
    aider-ralph "Implement auth. Output DONE when complete." \
        --completion-promise "DONE" --max-iterations 20

    # Using the specs file created by --init
    aider-ralph -f SPECS.md -m 30 -c "COMPLETE" -- --model sonnet --yes

    # TDD development loop
    aider-ralph -f tdd-prompt.md --max-iterations 50 \
        --completion-promise "ALL_TESTS_PASS" -- --model gpt-4o

PROMPT WRITING TIPS:
    1. Clear completion criteria - specify exactly when task is done
    2. Incremental goals - break large tasks into phases
    3. Self-correction patterns - include test/verify/fix cycles
    4. Escape hatches - document what to do if stuck

BASIC BASH LOOP (for reference):
    while :; do cat PROMPT.md | aider --message "$(cat PROMPT.md)" --yes; done

More info: https://awesomeclaude.ai/ralph-wiggum
EOF
}

# Print with timestamp
log() {
    local level="$1"
    shift
    local msg="$*"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case "$level" in
        INFO)  echo -e "${BLUE}[$timestamp]${NC} $msg" ;;
        OK)    echo -e "${GREEN}[$timestamp]${NC} âœ… $msg" ;;
        WARN)  echo -e "${YELLOW}[$timestamp]${NC} âš ï¸  $msg" ;;
        ERROR) echo -e "${RED}[$timestamp]${NC} âŒ $msg" ;;
        ITER)  echo -e "${PURPLE}[$timestamp]${NC} ğŸ”„ $msg" ;;
        *)     echo -e "[$timestamp] $msg" ;;
    esac

    if [[ -n "$LOG_FILE" ]]; then
        echo "[$timestamp] [$level] $msg" >> "$LOG_FILE"
    fi
}

# Print banner
print_banner() {
    echo -e "${CYAN}${BOLD}"
    cat << 'EOF'
    ____        __      __       ____        __      __
   / __ \____ _/ /___  / /_     / __ \____ _/ /___  / /_
  / /_/ / __ `/ / __ \/ __ \   / /_/ / __ `/ / __ \/ __ \
 / _, _/ /_/ / / /_/ / / / /  / _, _/ /_/ / / /_/ / / / /
/_/ |_|\__,_/_/ .___/_/ /_/  /_/ |_|\__,_/_/ .___/_/ /_/
             /_/                          /_/
EOF
    echo -e "${NC}"
    echo -e "${YELLOW}Ralph Wiggum AI Loop Technique for Aider${NC}"
    echo -e "${CYAN}\"I'm learnding!\" - Ralph Wiggum${NC}"
    echo ""
}

# Initialize project for aider-ralph
init_project() {
    local project_name="${PROJECT_NAME:-$(basename "$(pwd)")}"
    local specs_file="SPECS.md"
    local ralph_dir=".ralph"
    local config_file="$ralph_dir/config"
    local logs_dir="$ralph_dir/logs"

    echo -e "${CYAN}Initializing aider-ralph project: ${BOLD}$project_name${NC}"
    echo ""

    # Check if already initialized
    if [[ -f "$specs_file" ]]; then
        echo -e "${YELLOW}âš ï¸  $specs_file already exists. Skipping...${NC}"
    else
        # Create SPECS.md
        cat > "$specs_file" << SPECS_EOF
# $project_name

## Project Overview
<!-- Describe what this project does in 2-3 sentences -->


## Goals
<!-- What are you trying to build? Be specific. -->

1.
2.
3.

## Technical Requirements
<!-- List specific technical requirements -->

- [ ]
- [ ]
- [ ]

## Architecture & Design
<!-- Describe the high-level architecture -->


## Implementation Phases
<!-- Break the work into phases. Each phase should be completable in one Ralph loop session -->

### Phase 1: Foundation
<!-- Start with the basics -->

**Requirements:**
- [ ]
- [ ]

**Success Criteria:**
- All requirements implemented
- Tests passing

**When Phase 1 is complete, output:** \`PHASE1_COMPLETE\`

### Phase 2: Core Features
<!-- Build the main functionality -->

**Requirements:**
- [ ]
- [ ]

**Success Criteria:**
- All requirements implemented
- Tests passing

**When Phase 2 is complete, output:** \`PHASE2_COMPLETE\`

### Phase 3: Polish & Testing
<!-- Final touches -->

**Requirements:**
- [ ]
- [ ]

**Success Criteria:**
- All requirements implemented
- All tests passing
- Code reviewed and clean

**When Phase 3 is complete, output:** \`COMPLETE\`

## Development Process
<!-- Instructions for aider on how to work -->

1. Read and understand the current phase requirements
2. Implement one requirement at a time
3. Write tests for each requirement
4. Run tests after each change
5. If tests fail, debug and fix before moving on
6. Mark requirements as done [x] when complete
7. Move to next phase when all requirements are complete

## Commands
<!-- Useful commands for the project -->

\`\`\`bash
# Run tests
npm test  # or pytest, cargo test, etc.

# Start development server
npm run dev

# Build
npm run build

# Lint
npm run lint
\`\`\`

## Notes
<!-- Any additional context for the AI -->


---

## Completion Signal

When ALL phases are complete and the project is ready:

**COMPLETE**

If stuck for more than 10 iterations on the same issue:
- Document what's blocking progress
- List attempted solutions
- Suggest what information or help is needed
- Output: **NEEDS_HUMAN_REVIEW**
SPECS_EOF

        echo -e "${GREEN}âœ… Created $specs_file${NC}"
    fi

    # Create .ralph directory
    if [[ -d "$ralph_dir" ]]; then
        echo -e "${YELLOW}âš ï¸  $ralph_dir/ already exists. Skipping...${NC}"
    else
        mkdir -p "$ralph_dir"
        mkdir -p "$logs_dir"
        echo -e "${GREEN}âœ… Created $ralph_dir/ directory${NC}"
    fi

    # Create config file
    if [[ -f "$config_file" ]]; then
        echo -e "${YELLOW}âš ï¸  $config_file already exists. Skipping...${NC}"
    else
        cat > "$config_file" << CONFIG_EOF
# aider-ralph configuration
# These are default settings that can be overridden via command line

# Maximum iterations before stopping (safety net)
MAX_ITERATIONS=30

# Phrase that signals completion
COMPLETION_PROMISE=COMPLETE

# Delay between iterations in seconds
ITERATION_DELAY=2

# Default specs file
SPECS_FILE=SPECS.md

# Aider model (uncomment to set default)
# AIDER_MODEL=sonnet

# Aider options (space-separated)
# AIDER_EXTRA_OPTS=--yes
CONFIG_EOF

        echo -e "${GREEN}âœ… Created $config_file${NC}"
    fi

    # Add to .gitignore if it exists
    if [[ -f ".gitignore" ]]; then
        if ! grep -q "^\.ralph/logs" .gitignore 2>/dev/null; then
            echo "" >> .gitignore
            echo "# aider-ralph logs" >> .gitignore
            echo ".ralph/logs/" >> .gitignore
            echo -e "${GREEN}âœ… Added .ralph/logs/ to .gitignore${NC}"
        fi
    fi

    echo ""
    echo -e "${BOLD}Project initialized!${NC}"
    echo ""
    echo -e "${CYAN}Next steps:${NC}"
    echo -e "  1. Edit ${BOLD}SPECS.md${NC} with your project requirements"
    echo -e "  2. Optionally edit ${BOLD}.ralph/config${NC} for default settings"
    echo -e "  3. Run: ${BOLD}aider-ralph -f SPECS.md -m 30 -c COMPLETE -- --model sonnet${NC}"
    echo ""
    echo -e "${CYAN}Tips:${NC}"
    echo -e "  â€¢ Break work into small, verifiable phases"
    echo -e "  â€¢ Include test commands so aider can verify its work"
    echo -e "  â€¢ Use clear completion signals (PHASE1_COMPLETE, COMPLETE, etc.)"
    echo -e "  â€¢ Set realistic max-iterations as a safety net"
    echo ""
}

# Parse arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --init)
                DO_INIT=true
                shift
                # Check if next arg is a project name (not starting with -)
                if [[ $# -gt 0 && ! "$1" =~ ^- ]]; then
                    PROJECT_NAME="$1"
                    shift
                fi
                ;;
            -m|--max-iterations)
                MAX_ITERATIONS="$2"
                shift 2
                ;;
            -c|--completion-promise)
                COMPLETION_PROMISE="$2"
                shift 2
                ;;
            -f|--file)
                PROMPT_FILE="$2"
                shift 2
                ;;
            -d|--delay)
                ITERATION_DELAY="$2"
                shift 2
                ;;
            -l|--log)
                LOG_FILE="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            --)
                shift
                AIDER_OPTS=("$@")
                break
                ;;
            -*)
                echo -e "${RED}Unknown option: $1${NC}" >&2
                usage
                exit 1
                ;;
            *)
                if [[ -z "$PROMPT" ]]; then
                    PROMPT="$1"
                else
                    echo -e "${RED}Unexpected argument: $1${NC}" >&2
                    usage
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# Validate inputs
validate() {
    # Check if aider is installed
    if ! command -v aider &> /dev/null; then
        log ERROR "aider is not installed. Install with: pip install aider-chat"
        exit 1
    fi

    # Must have either prompt or prompt file
    if [[ -z "$PROMPT" && -z "$PROMPT_FILE" ]]; then
        log ERROR "No prompt provided. Use a prompt argument or -f <file>"
        usage
        exit 1
    fi

    # If file specified, check it exists
    if [[ -n "$PROMPT_FILE" && ! -f "$PROMPT_FILE" ]]; then
        log ERROR "Prompt file not found: $PROMPT_FILE"
        exit 1
    fi

    # Warn if no max iterations (safety)
    if [[ "$MAX_ITERATIONS" -eq 0 ]]; then
        log WARN "No --max-iterations set. Loop will run indefinitely!"
        log WARN "Press Ctrl+C to stop, or set --max-iterations for safety"
        echo ""
    fi
}

# Get the current prompt (from file or argument)
get_prompt() {
    if [[ -n "$PROMPT_FILE" ]]; then
        cat "$PROMPT_FILE"
    else
        echo "$PROMPT"
    fi
}

# Check if output contains completion promise
check_completion() {
    local output="$1"
    if [[ -n "$COMPLETION_PROMISE" ]]; then
        if echo "$output" | grep -qF "$COMPLETION_PROMISE"; then
            return 0  # Found completion promise
        fi
    fi
    return 1  # Not found or no promise set
}

# Run single iteration
run_iteration() {
    local iteration="$1"
    local prompt
    prompt=$(get_prompt)

    log ITER "Iteration $iteration starting..."

    if $VERBOSE; then
        echo -e "${CYAN}--- Prompt ---${NC}"
        echo "$prompt" | head -20
        if [[ $(echo "$prompt" | wc -l) -gt 20 ]]; then
            echo "... (truncated)"
        fi
        echo -e "${CYAN}--------------${NC}"
    fi

    # Build aider command (handle empty AIDER_OPTS array)
    local cmd=(aider --message "$prompt" --yes)
    if [[ ${#AIDER_OPTS[@]} -gt 0 ]]; then
        cmd+=("${AIDER_OPTS[@]}")
    fi

    if $VERBOSE; then
        log INFO "Running: ${cmd[*]}"
    fi

    if $DRY_RUN; then
        log INFO "[DRY RUN] Would execute: ${cmd[*]}"
        return 1  # Continue loop in dry run
    fi

    # Run aider and capture output
    local output
    local exit_code=0

    # Create temp file for output
    local temp_output
    temp_output=$(mktemp)

    # Run aider, tee to both stdout and temp file
    if "${cmd[@]}" 2>&1 | tee "$temp_output"; then
        exit_code=0
    else
        exit_code=$?
    fi

    output=$(cat "$temp_output")
    rm -f "$temp_output"

    # Log output if logging enabled
    if [[ -n "$LOG_FILE" ]]; then
        echo "=== Iteration $iteration ===" >> "$LOG_FILE"
        echo "$output" >> "$LOG_FILE"
        echo "" >> "$LOG_FILE"
    fi

    # Check for completion
    if check_completion "$output"; then
        log OK "Completion promise '$COMPLETION_PROMISE' detected!"
        return 0  # Signal completion
    fi

    if [[ $exit_code -ne 0 ]]; then
        log WARN "Aider exited with code $exit_code (continuing loop)"
    fi

    return 1  # Continue loop
}

# Main loop
main_loop() {
    LOOP_ACTIVE=true
    CURRENT_ITERATION=0

    while $LOOP_ACTIVE; do
        ((CURRENT_ITERATION++))

        # Check max iterations
        if [[ "$MAX_ITERATIONS" -gt 0 && "$CURRENT_ITERATION" -gt "$MAX_ITERATIONS" ]]; then
            log WARN "Max iterations ($MAX_ITERATIONS) reached"
            break
        fi

        # Show progress
        if [[ "$MAX_ITERATIONS" -gt 0 ]]; then
            echo -e "\n${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${PURPLE}  ITERATION $CURRENT_ITERATION / $MAX_ITERATIONS${NC}"
            echo -e "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        else
            echo -e "\n${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${PURPLE}  ITERATION $CURRENT_ITERATION (unlimited)${NC}"
            echo -e "${BOLD}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}\n"
        fi

        # Run iteration
        if run_iteration "$CURRENT_ITERATION"; then
            log OK "Loop completed successfully after $CURRENT_ITERATION iteration(s)!"
            LOOP_ACTIVE=false
            break
        fi

        # Delay between iterations
        if $LOOP_ACTIVE && [[ "$ITERATION_DELAY" -gt 0 ]]; then
            log INFO "Waiting ${ITERATION_DELAY}s before next iteration..."
            sleep "$ITERATION_DELAY"
        fi
    done

    echo ""
    log INFO "Ralph loop finished. Total iterations: $CURRENT_ITERATION"
}

# Handle interrupt
handle_interrupt() {
    echo ""
    log WARN "Interrupted by user (Ctrl+C)"
    LOOP_ACTIVE=false
    exit 130
}
trap handle_interrupt INT

# Main entry point
main() {
    parse_args "$@"

    print_banner

    # Handle --init command
    if $DO_INIT; then
        init_project
        exit 0
    fi

    validate

    # Show configuration
    log INFO "Configuration:"
    if [[ -n "$PROMPT_FILE" ]]; then
        echo -e "  ${CYAN}Prompt file:${NC} $PROMPT_FILE"
    else
        echo -e "  ${CYAN}Prompt:${NC} ${PROMPT:0:50}..."
    fi
    echo -e "  ${CYAN}Max iterations:${NC} ${MAX_ITERATIONS:-unlimited}"
    if [[ -n "$COMPLETION_PROMISE" ]]; then
        echo -e "  ${CYAN}Completion promise:${NC} $COMPLETION_PROMISE"
    fi
    if [[ ${#AIDER_OPTS[@]} -gt 0 ]]; then
        echo -e "  ${CYAN}Aider options:${NC} ${AIDER_OPTS[*]}"
    fi
    if [[ -n "$LOG_FILE" ]]; then
        echo -e "  ${CYAN}Log file:${NC} $LOG_FILE"
    fi
    echo ""

    # Start the loop
    main_loop
}

# Run if executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
